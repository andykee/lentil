.. _user_guide.image_sensors:

*************
Image sensors
*************
Lentil does not provide an integrated detector modeling capability, but instead provides
a collection of functions in the :ref:`detector module<api.detector>` to help model
image sensors and represent some of the more commonly encountered noise sources.

Signal flow
===========
An image sensor converts photons striking a pixel into a digital signal. The signal
produced by each pixel is subject to a number of physical characteristics and is
degraded by a variety of noise sources. The core components of this process are
represented in the figure below:

.. image:: /_static/img/image_sensor_signal_flow.png
    :width: 75%


Photons striking a pixel during an integration time will result in the accumulation of
electrons in the pixel well. The fraction of photons striking a pixel that are collected
as electrons is the sensor's *quantum efficiency* (QE). Additional electrons "leaking"
into each pixel are represented as *dark signal*. The electrons collected in each pixel
during an integration time are converted to a voltage (up to some saturation point),
amplified, and converted to a digital signal by an ADC. Additional noise generated
during the readout and conversion of the analog signal is represented as *read noise*.

This is a somewhat simplistic model of a digital image sensor but it provides the
framework for capturing the majority of physical effects and noise sources present and
is easily extended to capture more complex and nuanced effects.

Input signal
------------

Charge collection
-----------------


Pixel effects
-------------


Analog to digital conversion
----------------------------



Noise sources
=============
* Shot noise due to randomness in the arrival and detection of photons
* The conversion of photons into electrons (quantum efficiency)
* Dark current due to thermally generated electrons inside each pixel
* Spatial nonuniformity due to variations in detector pixels and electronics
* Noise generated by the electronics which read out the pixel values
* Pixel defects like hot or dead pixels, and other imaging artifacts like cosmic ray
  strikes


The signal can be split into two primary groups:

* A light signal representing the irrandiance (photons/s/px) presented to the detector.
  Note that the light signal represents **all** sources of photon flux which may include
  near field (self-emission) contributions in addition to the scene being observed.
* A dark signal representing all other sources of electrons present in the detector that
  aren't due to the light signal. These sources include thermally generated dark current
  and any voltage offsets.

Various noise sources also contribute to the eventual digital signal read out by the
detector. These noise sources can be broadly classified into two groups:

* Fixed-pattern noise is time-invariant and does not change from frame to frame. Fixed
  pattern noise can be thought of as a characteristic of the detector
* Temporal noise varies from frame to frame and typically represents random processes in t
  he detection and readout of an image




Imaging artifacts
=================

.. currentmodule:: lentil

.. note::

    To ensure accuracy and avoid introducing ailiasing artifacts, the input data should
    be at least Nyquist sampled.

Smear
-----
Smear is used to represent image motion with a relatively low temporal frequency relative
to integration time. The motion occurs in a slowly varying or fixed direction over one
integration time. Lentil's :func:`smear` method represents smear as a linear
directional blur over some distance (or number of pixels):

.. code:: pycon

    >>> import lentil
    >>> import matplotlib.pyplot as plt
    >>> psf = ...  # PSF calculation details omitted
    >>> psf_smear = lentil.convolvable.smear(psf, distance=5e-5,
    ...                                      pixelscale=5e-6,
    ...                                      oversample=3)
    >>> plt.subplot(121), plt.imshow(psf)
    >>> plt.subplot(122), plt.imshow(psf_smear)

.. image:: /_static/img/api/convolvable/smear_px.png
    :width: 500px

As an alternative to specifying physical distance and pixelscale, a number of pixels can also
be provided:

.. code:: pycon

    >>> import lentil
    >>> import matplotlib.pyplot as plt
    >>> psf = ...  # PSF calculation details omitted
    >>> psf_smear = lentil.convolvable.smear(psf, distance=10,
    ...                                      oversample=3)
    >>> plt.subplot(121), plt.imshow(psf)
    >>> plt.subplot(122), plt.imshow(psf_smear)

.. image:: /_static/img/api/convolvable/smear_px.png
    :width: 500px

The default behavior is to choose a new random smear direction each time :func:`smear`
is called, but a static direction can optionally be specified as needed:

.. code:: pycon

    >>> import lentil
    >>> import matplotlib.pyplot as plt
    >>> psf = ...  # PSF calculation details omitted
    >>> psf_smear = lentil.convolvable.smear(psf, distance=50,
    ...                                      angle=30)
    >>> plt.subplot(121), plt.imshow(psf)
    >>> plt.subplot(122), plt.imshow(psf_smear)

.. image:: /_static/img/api/convolvable/smear_m.png
    :width: 500px


Jitter
------
Jitter is used to represent image motion with a relatively high temporal frequency relative
to integration time. Lentil's :func:`jitter` method represents jitter with a
Gaussian blur operation. Note this approach is only valid if the motion occurs randomly in all
directions during one integration time.

.. code:: pycon

    >>> import lentil
    >>> import matplotlib.pyplot as plt
    >>> psf = ...  # PSF calculation details omitted
    >>> psf_jitter = lentil.convolvable.jitter(psf, scale=2)
    >>> plt.subplot(121), plt.imshow(psf)
    >>> plt.subplot(122), plt.imshow(psf_jitter)

.. image:: /_static/img/api/convolvable/jitter_px.png
    :width: 500px

If the jitter direction is not sufficiently random during a typical integration time, a timeseries
should be used instead. Note this will have a major impact on propagation performance but will
provide the most accurate results.

Pixel MTF
---------
A focal plane array samples a continuous light field to produce a digital image. Because
Lentil models diffraction numerically by propagating a finite set of points through an
optical system, the discretely sampled image plane intensity must be convolved with the
pixel's aperture function to accurately represent the intensity signal seen by each
pixel. Lentil's :func:`pixel` method implements this convolution.
After convolving the image plane intensity with the pixel MTF, the data should be
resampled to native detector sampling using :func:`rescale`. The
:func:`detector.pixelate` method combines the convolution and resampling operations
into a single method.
